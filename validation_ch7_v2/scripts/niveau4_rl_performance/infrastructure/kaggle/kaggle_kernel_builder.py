"""
Kaggle Kernel Script Builder.

Responsibilities:
- Generate Python scripts for Kaggle kernels
- Build validation execution scripts
- Include cleanup and artifact preservation logic

Single Responsibility: Kernel script generation
"""

import logging
from typing import Optional, Dict, Any
from pathlib import Path


class KaggleKernelBuilder:
    """
    Kernel script builder for validation workflows.
    
    Generates Python scripts that will run on Kaggle GPU environment.
    """
    
    def __init__(self):
        """Initialize kernel builder."""
        self.logger = logging.getLogger(__name__)
    
    def build_validation_script(
        self,
        repo_url: str,
        branch: str,
        script_path: str,
        quick_mode: bool = False,
        device: str = "gpu",
        cleanup_repo: bool = True
    ) -> str:
        """
        Build validation kernel script.
        
        Args:
            repo_url: GitHub repository URL
            branch: Git branch to clone
            script_path: Path to validation script in repo
            quick_mode: Enable quick test mode
            device: Device to use (gpu/cpu)
            cleanup_repo: Delete repo after execution to save space
            
        Returns:
            Complete Python script content
        """
        self.logger.info(f"🔨 Building validation kernel script")
        self.logger.info(f"   Repository: {repo_url}")
        self.logger.info(f"   Branch: {branch}")
        self.logger.info(f"   Script: {script_path}")
        self.logger.info(f"   Quick mode: {quick_mode}")
        self.logger.info(f"   Device: {device}")
        
        # Build script sections
        header = self._build_header()
        setup = self._build_setup_section(repo_url, branch)
        execution = self._build_execution_section(script_path, quick_mode, device)
        cleanup = self._build_cleanup_section(cleanup_repo)
        session_marker = self._build_session_marker()
        
        # Combine all sections
        script = "\n\n".join([
            header,
            setup,
            execution,
            cleanup,
            session_marker
        ])
        
        return script
    
    def _build_header(self) -> str:
        """Build script header with imports."""
        return '''"""
ARZ-RL Validation - Kaggle GPU Execution
Auto-generated by KaggleKernelBuilder
"""

import os
import sys
import json
import shutil
import subprocess
from pathlib import Path
from datetime import datetime

print("=" * 80)
print("🚀 ARZ-RL VALIDATION - KAGGLE GPU EXECUTION")
print("=" * 80)
print(f"Start time: {datetime.now().isoformat()}")
print(f"Python: {sys.version}")
print(f"Working directory: {os.getcwd()}")
print("=" * 80)
'''
    
    def _build_setup_section(self, repo_url: str, branch: str) -> str:
        """Build repository setup section."""
        return f'''# ═══════════════════════════════════════════════════════════════════════
# PHASE 1: CLONE REPOSITORY
# ═══════════════════════════════════════════════════════════════════════

print("\\n📦 PHASE 1: Cloning repository...")
print(f"Repository: {repo_url}")
print(f"Branch: {branch}")

repo_dir = Path("/kaggle/working/repo")

try:
    # Clone repository
    subprocess.run(
        ["git", "clone", "-b", "{branch}", "{repo_url}", str(repo_dir)],
        check=True,
        timeout=300
    )
    print(f"✅ Repository cloned to: {{repo_dir}}")
    
    # Change to repo directory
    os.chdir(repo_dir)
    print(f"✅ Working directory: {{os.getcwd()}}")
    
except Exception as e:
    print(f"❌ Repository clone failed: {{e}}")
    sys.exit(1)
'''
    
    def _build_execution_section(self, script_path: str, quick_mode: bool, device: str) -> str:
        """Build validation execution section."""
        quick_flag = "--quick" if quick_mode else ""
        
        return f'''# ═══════════════════════════════════════════════════════════════════════
# PHASE 2: RUN VALIDATION
# ═══════════════════════════════════════════════════════════════════════

print("\\n🧪 PHASE 2: Running validation...")
print(f"Script: {script_path}")
print(f"Quick mode: {quick_mode}")
print(f"Device: {device}")

results_dir = Path("/kaggle/working/validation_results")
results_dir.mkdir(parents=True, exist_ok=True)

try:
    # Build command
    cmd = [
        "python", "{script_path}",
        "--device", "{device}",
        {f'"{quick_flag}",' if quick_flag else ''}
    ]
    cmd = [c for c in cmd if c]  # Remove empty strings
    
    print(f"Command: {{' '.join(cmd)}}")
    print("=" * 80)
    
    # Run validation
    result = subprocess.run(
        cmd,
        cwd=repo_dir,
        timeout=14400  # 4 hours max
    )
    
    if result.returncode == 0:
        print("=" * 80)
        print("✅ Validation completed successfully")
    else:
        print("=" * 80)
        print(f"⚠️  Validation exited with code: {{result.returncode}}")
    
except subprocess.TimeoutExpired:
    print("❌ Validation timeout (4 hours)")
except Exception as e:
    print(f"❌ Validation failed: {{e}}")
    
# Copy results to working directory
print("\\n📋 Copying results...")
try:
    # Find section_7_6_results directory
    section_results = repo_dir / "validation_ch7_v2" / "scripts" / "niveau4_rl_performance" / "section_7_6_results"
    
    if section_results.exists():
        # Copy all results
        for item in section_results.glob("**/*"):
            if item.is_file():
                rel_path = item.relative_to(section_results)
                dest = results_dir / rel_path
                dest.parent.mkdir(parents=True, exist_ok=True)
                shutil.copy2(item, dest)
                print(f"   ✅ {{rel_path}}")
        
        print(f"✅ Results copied to: {{results_dir}}")
    else:
        print(f"⚠️  Results directory not found: {{section_results}}")
        
except Exception as e:
    print(f"⚠️  Failed to copy results: {{e}}")
'''
    
    def _build_cleanup_section(self, cleanup_repo: bool) -> str:
        """Build cleanup section."""
        if not cleanup_repo:
            return "# Cleanup disabled - repo preserved"
        
        return '''# ═══════════════════════════════════════════════════════════════════════
# PHASE 3: CLEANUP
# ═══════════════════════════════════════════════════════════════════════

print("\\n🧹 PHASE 3: Cleanup...")

try:
    # Change back to working directory
    os.chdir("/kaggle/working")
    
    # Remove repository (save space)
    if repo_dir.exists():
        shutil.rmtree(repo_dir)
        print(f"✅ Repository cleaned up")
    
    # List final outputs
    print("\\n📁 Final outputs:")
    for item in results_dir.glob("**/*"):
        if item.is_file():
            size = item.stat().st_size
            rel_path = item.relative_to(results_dir)
            print(f"   📄 {rel_path} ({size:,} bytes)")
    
except Exception as e:
    print(f"⚠️  Cleanup warning: {e}")
'''
    
    def _build_session_marker(self) -> str:
        """Build session completion marker."""
        return '''# ═══════════════════════════════════════════════════════════════════════
# SESSION COMPLETE MARKER
# ═══════════════════════════════════════════════════════════════════════

print("\\n" + "=" * 80)
print("✅ SESSION_COMPLETE")
print(f"End time: {datetime.now().isoformat()}")
print("=" * 80)

# Write session summary
session_summary = {
    "status": "complete",
    "timestamp": datetime.now().isoformat(),
    "results_dir": str(results_dir),
    "files_generated": len(list(results_dir.glob("**/*")))
}

summary_path = Path("/kaggle/working/session_summary.json")
summary_path.write_text(json.dumps(session_summary, indent=2))
print(f"✅ Session summary written: {summary_path}")
'''
