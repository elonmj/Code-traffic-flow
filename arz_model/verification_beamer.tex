\documentclass[10pt,aspectratio=169]{beamer}
\usetheme{Madrid}
\usecolortheme{default}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{textcomp}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.98,0.98,0.98}

\lstdefinestyle{pythonstyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=Python,
    literate={é}{{\'e}}1 {è}{{\`e}}1 {à}{{\`a}}1 {ê}{{\^e}}1 {ç}{{\c c}}1
}
\lstset{style=pythonstyle}

\tikzstyle{startstop} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=red!30]
\tikzstyle{io} = [trapezium, trapezium left angle=70, trapezium right angle=110, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=blue!30]
\tikzstyle{process} = [rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=orange!30]
\tikzstyle{decision} = [diamond, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=green!30]
\tikzstyle{arrow} = [thick,->,>=stealth]

\title[Chaîne Numérique ARZ]{Présentation de la Chaîne Numérique}
\subtitle{Modèle de trafic ARZ multi-classe}
\author{Analyse par IA Experte en Mathématiques Appliquées}
\institute{Projet Alibi}
\date{\today}

\begin{document}

% --- Title Slide ---
\begin{frame}
    \titlepage
\end{frame}

% --- Table of Contents ---
\begin{frame}
    \frametitle{Plan de la Présentation}
    \tableofcontents
\end{frame}

% --- Introduction Section ---
\section{Introduction et Contexte}

\begin{frame}
    \frametitle{Objectif de la Présentation}
    \begin{block}{Mission}
        Présenter l'architecture et la rigueur mathématique de l'implémentation du modèle de trafic Aw-Rascle-Zhang (ARZ) multi-classe.
    \end{block}
    
    \begin{itemize}
        \item \textbf{Modèle Physique}: Comment le code implémente-t-il les équations du modèle ARZ ?
        \item \textbf{Chaîne Numérique}: Quels sont les schémas numériques utilisés et comment sont-ils implémentés ?
        \item \textbf{Couplage}: Comment les différentes parties de la simulation interagissent-elles ?
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{La Chaîne Numérique : Vue d'Ensemble}
    \begin{tikzpicture}[node distance=2cm]

    \node(start) [startstop] {État Initial $U^n$};
    \node(pro1) [process, below of=start] {1. Étape Source (dt/2)};
    \node(pro2) [process, below of=pro1, yshift=-0.5cm] {2. Étape Hyperbolique (dt)};
    \node(pro3) [process, below of=pro2, yshift=-0.5cm] {3. Étape Source (dt/2)};
    \node(stop) [startstop, below of=pro3] {État Final $U^{n+1}$};
    
    \draw [arrow] (start) -- (pro1);
    \draw [arrow] (pro1) -- node[right] {Strang Splitting} (pro2);
    \draw [arrow] (pro2) -- (pro3);
    \draw [arrow] (pro3) -- (stop);
    
    \node(weno) [io, right of=pro2, xshift=4cm] {Reconstruction WENO5};
    \node(flux) [io, below of=weno] {Flux Central-Upwind};
    \node(rk3) [io, above of=weno] {Intégration SSP-RK3};
    
    \draw [arrow, dashed] (pro2.east) -- (rk3.west);
    \draw [arrow, dashed] (rk3.south) -- (weno.north);
    \draw [arrow, dashed] (weno.south) -- (flux.north);

    \end{tikzpicture}
    
    \begin{exampleblock}{Fichiers Clés Analysés}
        \tiny
        \begin{itemize}
            \item \texttt{core/physics.py}
            \item \texttt{numerics/reconstruction/weno\_gpu.py}
            \item \texttt{numerics/riemann\_solvers.py}
            \item \texttt{numerics/gpu/ssp\_rk3\_cuda.py}
            \item \texttt{numerics/time\_integration.py}
        \end{itemize}
    \end{exampleblock}
\end{frame}

% --- Physics Section ---
\section{Le Modèle Physique (ARZ)}

\begin{frame}
    \frametitle{Le Système d'Équations ARZ Multi-Classe}
    Le modèle décrit l'évolution de 4 variables pour deux classes de véhicules (motos 'm', voitures 'c'):
    \begin{itemize}
        \item $\rho_m, \rho_c$: densités partielles
        \item $w_m, w_c$: variables de moment (lagrangiennes)
    \end{itemize}
    
    \vspace{0.5cm}
    
    \textbf{Système d'équations (forme non-conservative):}
    \begin{align*}
        \frac{\partial \rho_m}{\partial t} + \frac{\partial (\rho_m v_m)}{\partial x} &= 0 \\
        \frac{\partial w_m}{\partial t} + v_m \frac{\partial w_m}{\partial x} &= \frac{V_e(\rho) - v_m}{\tau_m} \\
        \frac{\partial \rho_c}{\partial t} + \frac{\partial (\rho_c v_c)}{\partial x} &= 0 \\
        \frac{\partial w_c}{\partial t} + v_c \frac{\partial w_c}{\partial x} &= \frac{V_e(\rho) - v_c}{\tau_c}
    \end{align*}
    
    \begin{alertblock}{Relation Fondamentale ARZ}
        La vitesse physique $v$ est liée à la variable de moment $w$ et à une "pression" $p(\rho)$ :
        $$ v = w - p(\rho) $$
    \end{alertblock}
\end{frame}

\begin{frame}[fragile]
    \frametitle{La Pression $p(\rho)$ : Théorie et Implémentation}
    \begin{columns}[T]
        \begin{column}{0.5\textwidth}
            \begin{block}{Formule Théorique}
                $$ p = K \left( \frac{\rho_{eff}}{\rho_{jam}} \right)^\gamma $$
            \end{block}
            
            \begin{alertblock}{Densités Effectives}
                \begin{itemize}
                    \item Motos: $\rho_{eff,m} = \rho_m + \alpha \rho_c$
                    \item Voitures: $\rho_{eff,c} = \rho_m + \rho_c$
                \end{itemize}
            \end{alertblock}
        \end{column}
        \begin{column}{0.5\textwidth}
            \begin{exampleblock}{Code (\texttt{core/physics.py})}
\begin{lstlisting}
// Calcul de la pression
rho_eff_m = rho_m_i + alpha * rho_c_i
rho_total = rho_m_i + rho_c_i

norm_rho_m = rho_eff_m / rho_jam_m
p_m = K_m * (norm_rho_m**gamma_m)

norm_rho_c = rho_total / rho_jam_c
p_c = K_c * (norm_rho_c**gamma_c)
\end{lstlisting}
            \end{exampleblock}
        \end{column}
    \end{columns}
    \begin{center}
        \textbf{\textcolor{codegreen}{Conclusion : Implémentation fidèle à la théorie.}}
    \end{center}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Vitesses et Valeurs Propres : Théorie et Implémentation}
     \begin{columns}[T]
        \begin{column}{0.5\textwidth}
            \begin{block}{Valeurs Propres}
                \begin{align*}
                    \lambda_1 &= v_m \\
                    \lambda_2 &= v_m - \rho_m \frac{\partial p_m}{\partial \rho_m} \\
                    \lambda_3 &= v_c \\
                    \lambda_4 &= v_c - \rho_c \frac{\partial p_c}{\partial \rho_c}
                \end{align*}
            \end{block}
        \end{column}
        \begin{column}{0.5\textwidth}
            \begin{exampleblock}{Code (\texttt{core/physics.py})}
\begin{lstlisting}
// v = w - p
v_m_i = w_m_i - p_m_i
v_c_i = w_c_i - p_c_i

// Derivee de la pression
P_prime_m_i = K_m * g_m * 
 (norm_rho_m**(g_m-1.0)) / rho_jam_m

// Valeurs propres
lambda1 = v_m_i
lambda2 = v_m_i - rho_m_calc * P_prime_m_i
lambda3 = v_c_i
lambda4 = v_c_i - rho_c_calc * P_prime_c_i
\end{lstlisting}
            \end{exampleblock}
        \end{column}
    \end{columns}
    \begin{center}
        \textbf{\textcolor{codegreen}{Conclusion : Calcul des vitesses et valeurs propres correct.}}
    \end{center}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Le Terme Source (Relaxation) : Théorie et Implémentation}
    \begin{columns}[T]
        \begin{column}{0.5\textwidth}
            \begin{block}{Formule Théorique}
                $$ S(U) = \begin{pmatrix} 0 \\ (V_e - v_m)/\tau_m \\ 0 \\ (V_e - v_c)/\tau_c \end{pmatrix} $$
            \end{block}
            \small
            Le terme source modélise la relaxation de la vitesse $v$ vers une vitesse d'équilibre $V_e$.
        \end{column}
        \begin{column}{0.5\textwidth}
            \begin{exampleblock}{Code (\texttt{core/physics.py})}
\begin{lstlisting}
def calculate_source_term_gpu(...):
    v_m_i = w_m_i - p_m_i
    v_c_i = w_c_i - p_c_i
    
    // Terme source pour chaque classe
    Sm_i = (Ve_m_i - v_m_i) / tau_m_i
    Sc_i = (Ve_c_i - v_c_i) / tau_c_i
    
    // Le vecteur source n'affecte 
    // que les moments
\end{lstlisting}
            \end{exampleblock}
        \end{column}
    \end{columns}
    \begin{center}
        \textbf{\textcolor{codegreen}{Conclusion : Le terme source est correctement implémenté.}}
    \end{center}
\end{frame}

% --- Numerics Section ---
\section{La Chaîne Numérique}

\begin{frame}
    \frametitle{Principe : La Méthode des Volumes Finis}
    \begin{block}{Objectif}
        Transformer le système d'équations aux dérivées partielles (PDE) en un système d'équations différentielles ordinaires (ODE) que l'on peut résoudre numériquement.
    \end{block}
    
    L'équation de conservation pour une cellule $i$ s'écrit :
    $$ \frac{d U_i}{dt} = - \frac{1}{\Delta x} \left( F_{i+1/2} - F_{i-1/2} \right) $$
    
    \begin{alertblock}{Les deux défis majeurs}
    \begin{enumerate}
        \item \textbf{Comment calculer le flux $F_{i+1/2}$ à l'interface ?}
        \begin{itemize}
            \item Cela nécessite de connaître les valeurs de $U$ de part et d'autre de l'interface.
        \end{itemize}
        \item \textbf{Comment faire avancer la solution $U_i$ dans le temps ?}
        \begin{itemize}
            \item Il faut un intégrateur temporel stable et précis.
        \end{itemize}
    \end{enumerate}
    \end{alertblock}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Reconstruction Spatiale : WENO5}
    \framesubtitle{Référence : Jiang \& Shu (1996)}
    
    \begin{block}{Objectif}
        Reconstruire les valeurs aux interfaces ($u_{i+1/2}$) avec une précision du 5\textsuperscript{ème} ordre, sans créer d'oscillations près des chocs.
    \end{block}
    
    \textbf{Étapes clés de l'algorithme WENO5 :}
    \begin{enumerate}
        \item Calcul des \textbf{indicateurs de régularité} ($\beta_k$) pour 3 stencils.
        \item Calcul des \textbf{poids non-linéaires} ($\omega_k$) qui favorisent les stencils "lisses".
        \item Combinaison des \textbf{polynômes de reconstruction} ($p_k$) pondérés par les $\omega_k$.
    \end{enumerate}
    
    \begin{alertblock}{Analyse de l'implémentation}
        L'implémentation dans \texttt{weno\_gpu.py} est une transcription \textbf{parfaite} des formules de Jiang \& Shu (1996) pour les $\beta_k$, les poids $\omega_k$ et les polynômes $p_k$.
    \end{alertblock}
\end{frame}

\begin{frame}
    \frametitle{Étape 2 : Calcul du Flux à l'Interface}
    \begin{block}{Problème}
        Une fois les valeurs $U_L$ (à gauche) et $U_R$ (à droite) de l'interface reconstruites par WENO, comment calculer le flux unique $F_{i+1/2}$ qui traverse cette interface ?
    \end{block}
    
    \begin{alertblock}{Solution : Le Solveur de Riemann}
        Un solveur de Riemann est une fonction qui prend en entrée les deux états ($U_L, U_R$) et retourne le flux numérique.
        $$ F_{i+1/2} = \text{RiemannSolver}(U_L, U_R) $$
        Notre choix se porte sur le schéma \textbf{Central-Upwind}.
    \end{alertblock}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Flux Numérique : Central-Upwind}
    \framesubtitle{Référence : Kurganov \& Tadmor (2000)}
    
    \begin{columns}[T]
        \begin{column}{0.5\textwidth}
            \begin{block}{Formule Théorique}
                \small
                $$ F_{CU} = \frac{a^+ F_L - a^- F_R}{a^+ - a^-} + \frac{a^+ a^-}{a^+ - a^-} (U_R - U_L) $$
                Où $a^+$ et $a^-$ sont les vitesses d'onde locales max/min.
            \end{block}
            
            \begin{alertblock}{Approximation sur le Flux de $w$}
                L'équation sur $w$ n'est pas conservative. Le flux est approximé, ce qui est une pratique standard et validée dans la littérature (Villa, 2016).
            \end{alertblock}
        \end{column}
        \begin{column}{0.5\textwidth}
            \begin{exampleblock}{Code (\texttt{riemann\_solvers.py})}
\begin{lstlisting}
a_plus = max(max(lambda_L), 
             max(lambda_R), 0.0)
a_minus = min(min(lambda_L), 
              min(lambda_R), 0.0)

den = a_plus - a_minus
term1 = (a_plus * F_L - a_minus * F_R) / den
term2 = (a_plus * a_minus / den) * (U_R - U_L)

F_CU = term1 + term2
\end{lstlisting}
            \end{exampleblock}
        \end{column}
    \end{columns}
    \begin{center}
        \textbf{\textcolor{codegreen}{Conclusion : Schéma de flux robuste et correctement implémenté.}}
    \end{center}
\end{frame}

\begin{frame}
    \frametitle{Étape 3 : Évolution Temporelle}
    \begin{block}{Problème}
        Nous avons maintenant une méthode pour calculer la dérivée spatiale pour chaque cellule $i$:
        $$ \frac{\partial U_i}{\partial t} = - \frac{F_{i+1/2} - F_{i-1/2}}{\Delta x} \equiv \mathcal{L}(U)_i $$
        Comment utiliser cette information pour faire avancer la solution de $t^n$ à $t^{n+1}$ ?
    \end{block}
    
    \begin{alertblock}{Solution : L'Intégration Temporelle}
        Nous devons résoudre un système d'équations différentielles ordinaires (EDO).
        $$ \frac{dU}{dt} = \mathcal{L}(U) $$
        Pour cela, nous utilisons une méthode de Runge-Kutta, spécifiquement la méthode \textbf{SSP-RK3} (Strong Stability Preserving, 3ème ordre) pour sa stabilité et sa précision.
    \end{alertblock}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Intégration Temporelle : SSP-RK3}
    \framesubtitle{Référence : Gottlieb \& Shu (1998)}
    
    \begin{columns}[T]
        \begin{column}{0.5\textwidth}
            \begin{block}{Schéma Runge-Kutta d'ordre 3}
                Pour $\frac{du}{dt} = \mathcal{L}(u)$ :
                \begin{align*}
                    u^{(1)} &= u^n + \Delta t \mathcal{L}(u^n) \\
                    u^{(2)} &= \frac{3}{4} u^n + \frac{1}{4} (u^{(1)} + \Delta t \mathcal{L}(u^{(1)})) \\
                    u^{n+1} &= \frac{1}{3} u^n + \frac{2}{3} (u^{(2)} + \Delta t \mathcal{L}(u^{(2)}))
                \end{align*}
            \end{block}
        \end{column}
        \begin{column}{0.5\textwidth}
            \begin{exampleblock}{Code (\texttt{ssp\_rk3\_cuda.py})}
\begin{lstlisting}
// Etape 1:
u_temp1 = u_n + dt * flux_div

// Etape 2:
u_temp2 = 0.75 * u_n + 0.25 * 
          (u_temp1 + dt * flux_div_1)

// Etape 3:
u_np1 = (1.0/3.0) * u_n + (2.0/3.0) * 
        (u_temp2 + dt * flux_div_2)
\end{lstlisting}
            \end{exampleblock}
        \end{column}
    \end{columns}
    \begin{center}
        
\textbf{\textcolor{codegreen}{Conclusion : Les coefficients et étapes du SSP-RK3 sont exacts.}}
\end{frame}

\begin{frame}
    \frametitle{Étape 4 : Couplage Physique-Hyperbolique}
    \begin{block}{Problème}
        L'équation complète contient un terme source $S(U)$ qui modélise la relaxation de la vitesse :
        $$ \frac{\partial U}{\partial t} + \frac{\partial F(U)}{\partial x} = S(U) $$
        Comment intégrer ce terme source avec notre solveur hyperbolique (WENO+Flux+RK3) ?
    \end{block}
    
    \begin{alertblock}{Solution : Le Splitting de Strang}
        Nous séparons l'équation en deux parties, résolues séquentiellement :
        \begin{enumerate}
            \item \textbf{Partie Hyperbolique :} $\frac{\partial U}{\partial t} + \frac{\partial F(U)}{\partial x} = 0$
            \item \textbf{Partie ODE (Source) :} $\frac{dU}{dt} = S(U)$
        \end{enumerate}
        Le \textbf{Splitting de Strang} (2ème ordre) combine ces étapes de manière symétrique pour une meilleure précision.
    \end{alertblock}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Couplage par Splitting de Strang
    \end{center}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Couplage des Opérateurs : Strang Splitting}
    
    \begin{columns}[T]
        \begin{column}{0.5\textwidth}
            \begin{block}{Objectif}
                Découpler la résolution de la partie hyperbolique (transport) de celle des termes sources (relaxation), en maintenant un ordre de précision 2.
            \end{block}
            
            \textbf{Schéma de Strang :}
            \begin{enumerate}
                \item Résoudre ODE (source) sur $\Delta t/2$.
                \item Résoudre PDE (transport) sur $\Delta t$.
                \item Résoudre ODE (source) sur $\Delta t/2$.
            \end{enumerate}
        \end{column}
        \begin{column}{0.5\textwidth}
            \begin{exampleblock}{Code (\texttt{time\_integration.py})}
\begin{lstlisting}
def strang_splitting_step_gpu_native(...):
    // 1. Premier sous-pas ODE (dt/2)
    d_U_star = solve_ode_step_gpu(
        d_U_n, dt / 2.0, ...)
    
    // 2. Sous-pas hyperbolique (dt)
    d_U_ss = solve_hyperbolic_step_ssp_rk3_gpu_native(...)
    
    // 3. Second sous-pas ODE (dt/2)
    d_U_np1 = solve_ode_step_gpu(
        d_U_ss, dt / 2.0, ...)
    
    return d_U_np1
\end{lstlisting}
            \end{exampleblock}
        \end{column}
    \end{columns}
    \begin{center}
        \textbf{\textcolor{codegreen}{Conclusion : Le couplage respecte le schéma de Strang d'ordre 2.}}
    \end{center}
\end{frame}

% --- Conclusion Section ---
\section{Conclusion et Références}

\begin{frame}
    \frametitle{Synthèse de la Chaîne Numérique}
    
    \begin{block}{Points Forts de l'Implémentation}
        \begin{itemize}
            \item \textbf{Fidélité au Modèle ARZ :} Structure des équations, pression multi-classe et termes sources conformes.
            \item \textbf{Méthodes Numériques Modernes :} Utilisation de schémas d'ordre élevé (WENO5, SSP-RK3) garantissant précision et stabilité.
            \item \textbf{Implémentation GPU Optimisée :} Les noyaux CUDA traduisent correctement les formules mathématiques pour une parallélisation massive.
        \end{itemize}
    \end{block}
    
    \begin{alertblock}{Approximations Documentées et Justifiées}
        \begin{itemize}
            \item Le traitement du flux de la variable $w$ comme conservatif est une approximation standard dans la littérature ARZ, validée par des auteurs comme S. Villa.
        \end{itemize}
    \end{alertblock}
    
    \begin{exampleblock}{Conclusion Générale}
        \Large\centerline{\textbf{L'implémentation est mathématiquement rigoureuse}}
        \vspace{0.2cm}
        \normalsize Le code est une traduction fidèle et de haut niveau de la théorie du modèle ARZ et des schémas numériques associés. Le niveau de conformité est académique.
    \end{exampleblock}
\end{frame}

\begin{frame}
    \frametitle{Références Académiques Clés}
    \small
    \begin{thebibliography}{99}
        \bibitem{AR2000}
        A. Aw \& M. Rascle,
        \textit{Resurrection of "second order" models of traffic flow},
        SIAM J. Appl. Math., 2000.
        
        \bibitem{JS1996}
        G. S. Jiang \& C.-W. Shu,
        \textit{Efficient implementation of weighted ENO schemes},
        Journal of Computational Physics, 1996.
        
        \bibitem{KT2000}
        A. Kurganov \& E. Tadmor,
        \textit{New high-resolution central schemes for nonlinear conservation laws...},
        Journal of Computational Physics, 2000.
        
        \bibitem{GS1998}
        S. Gottlieb \& C.-W. Shu,
        \textit{Total variation diminishing Runge-Kutta schemes},
        Mathematics of Computation, 1998.
        
        \bibitem{Villa2016}
        S. Villa,
        \textit{The Aw-Rascle-Zhang model with constraints},
        arXiv:1605.00632, 2016.
        
        \bibitem{Daganzo1995}
        C. F. Daganzo,
        \textit{The cell transmission model, part II: Network traffic},
        Transportation Research Part B, 1995.
    \end{thebibliography}
\end{frame}

\end{document}
