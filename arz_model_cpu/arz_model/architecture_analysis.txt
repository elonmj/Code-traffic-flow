
ğŸ“¦ ARZ_MODEL ARCHITECTURE ANALYSIS
================================================================================
Total: 72 modules, 333 functions, 55 classes

================================================================================
ğŸ“‚ DIRECTORY STRUCTURE WITH FUNCTIONS & CLASSES
================================================================================

ğŸ¯ arz_model/core/ (7 modules)
--------------------------------------------------------------------------------

  ğŸ“„ __init__.py

  ğŸ“„ intersection.py
     Classes (2):
       â€¢ Intersection
       â€¢ NetworkNode
     Functions (14):
       â€¢ __init__
       â€¢ update_queues
       â€¢ get_creeping_speed
       â€¢ get_outgoing_capacity
       â€¢ apply_creeping
       â€¢ get_queue_info
       â€¢ reset_stats
       â€¢ update_stats
       â€¢ get_config
       â€¢ __init__
       â€¢ add_segment
       â€¢ remove_segment
       â€¢ get_connected_segments
       â€¢ create_intersection_from_config

  ğŸ“„ node_solver.py
     Functions (8):
       â€¢ solve_node_fluxes
       â€¢ _calculate_outgoing_flux
       â€¢ _get_coupling_parameter
       â€¢ _apply_behavioral_coupling
       â€¢ _get_default_flux
       â€¢ solve_intersection_riemann
       â€¢ apply_priority_rules
       â€¢ update_node_queues

  ğŸ“„ parameter_manager.py
     Classes (1):
       â€¢ ParameterManager
     Functions (11):
       â€¢ __init__
       â€¢ set_local
       â€¢ set_local_dict
       â€¢ get
       â€¢ get_all
       â€¢ has_local
       â€¢ list_segments_with_overrides
       â€¢ get_overrides
       â€¢ clear_local
       â€¢ summary
       â€¢ __repr__

  ğŸ“„ parameters.py
     Classes (1):
       â€¢ ModelParameters
     Functions (7):
       â€¢ _deep_merge_dicts
       â€¢ __init__
       â€¢ _initialize_defaults
       â€¢ load_from_pydantic
       â€¢ load_from_yaml
       â€¢ _validate_parameters
       â€¢ __str__

  ğŸ“„ physics.py
     Functions (14):
       â€¢ calculate_pressure
       â€¢ _calculate_pressure_cuda
       â€¢ calculate_equilibrium_speed
       â€¢ calculate_equilibrium_speed_gpu
       â€¢ calculate_relaxation_time_gpu
       â€¢ calculate_relaxation_time
       â€¢ calculate_physical_velocity
       â€¢ _calculate_physical_velocity_cuda
       â€¢ _calculate_pressure_derivative
       â€¢ calculate_eigenvalues
       â€¢ _calculate_pressure_derivative_cuda
       â€¢ _calculate_eigenvalues_cuda
       â€¢ calculate_source_term
       â€¢ calculate_source_term_gpu

  ğŸ“„ traffic_lights.py
     Classes (3):
       â€¢ Phase
       â€¢ TrafficLightController
       â€¢ CoordinatedTrafficLightController
     Functions (25):
       â€¢ __init__
       â€¢ is_green
       â€¢ is_yellow
       â€¢ __init__
       â€¢ _create_default_phases
       â€¢ get_current_phase
       â€¢ get_current_green_segments
       â€¢ get_current_yellow_segments
       â€¢ get_time_to_next_phase
       â€¢ get_phase_progress
       â€¢ set_offset
       â€¢ add_phase
       â€¢ remove_phase
       â€¢ _update_cycle_time
       â€¢ get_cycle_info
       â€¢ reset_stats
       â€¢ update_stats
       â€¢ get_config
       â€¢ __init__
       â€¢ get_slave_offset
       â€¢ set_slave_offset
       â€¢ get_coordination_info
       â€¢ create_traffic_light_from_config
       â€¢ calculate_optimal_cycle_time
       â€¢ adapt_traffic_lights

ğŸ¯ arz_model/grid/ (2 modules)
--------------------------------------------------------------------------------

  ğŸ“„ __init__.py

  ğŸ“„ grid1d.py
     Classes (1):
       â€¢ Grid1D
     Functions (6):
       â€¢ __init__
       â€¢ load_road_quality
       â€¢ get_road_quality_for_cell
       â€¢ cell_centers
       â€¢ cell_interfaces
       â€¢ __str__

ğŸ¯ arz_model/numerics/ (15 modules)
--------------------------------------------------------------------------------

  ğŸ“„ __init__.py

  ğŸ“„ boundary_conditions.py
     Functions (2):
       â€¢ _apply_boundary_conditions_kernel
       â€¢ apply_boundary_conditions

  ğŸ“„ cfl.py
     Functions (3):
       â€¢ _calculate_max_wavespeed_kernel
       â€¢ calculate_cfl_dt
       â€¢ cfl_condition

  ğŸ“„ checkpoint_manager.py
     Classes (1):
       â€¢ CheckpointManager
     Functions (8):
       â€¢ __init__
       â€¢ should_checkpoint
       â€¢ save_checkpoint
       â€¢ detect_instability
       â€¢ rollback
       â€¢ reset_consecutive_rollbacks
       â€¢ get_statistics
       â€¢ print_statistics

  ğŸ“„ __init__.py

  ğŸ“„ ssp_rk3_cuda.py
     Classes (1):
       â€¢ SSP_RK3_GPU
     Functions (8):
       â€¢ ssp_rk3_stage1_kernel
       â€¢ ssp_rk3_stage2_kernel
       â€¢ ssp_rk3_stage3_kernel
       â€¢ compute_flux_divergence_kernel
       â€¢ __init__
       â€¢ integrate_step
       â€¢ cleanup
       â€¢ integrate_ssp_rk3_gpu

  ğŸ“„ utils.py
     Classes (1):
       â€¢ GPUMemoryManager
     Functions (10):
       â€¢ check_cuda_availability
       â€¢ get_optimal_block_size
       â€¢ profile_gpu_kernel
       â€¢ validate_gpu_vs_cpu
       â€¢ __init__
       â€¢ allocate_device_array
       â€¢ get_current_memory_usage
       â€¢ get_memory_stats
       â€¢ cleanup
       â€¢ benchmark_weno_implementations

  ğŸ“„ weno_cuda.py
     Functions (5):
       â€¢ weno5_reconstruction_naive_kernel
       â€¢ apply_boundary_conditions_kernel
       â€¢ reconstruct_weno5_gpu_naive
       â€¢ weno5_reconstruction_optimized_kernel
       â€¢ reconstruct_weno5_gpu_optimized

  ğŸ“„ logging_utils.py
     Functions (3):
       â€¢ should_log
       â€¢ set_log_interval
       â€¢ reset_log_timer

  ğŸ“„ network_coupling_corrected.py
     Classes (1):
       â€¢ NetworkCouplingCorrected
     Functions (10):
       â€¢ __init__
       â€¢ _build_segment_mapping
       â€¢ apply_network_coupling
       â€¢ _collect_real_boundary_states
       â€¢ _solve_node_conservation
       â€¢ _enforce_mass_conservation
       â€¢ _apply_physical_boundary_conditions
       â€¢ _update_node_state
       â€¢ apply_network_coupling_cpu_corrected
       â€¢ apply_network_coupling_gpu_corrected

  ğŸ“„ converter.py
     Functions (4):
       â€¢ conserved_to_primitives_arr
       â€¢ primitives_to_conserved_arr
       â€¢ conserved_to_primitives_arr_gpu
       â€¢ primitives_to_conserved_arr_gpu

  ğŸ“„ weno.py
     Functions (1):
       â€¢ reconstruct_weno5

  ğŸ“„ weno_gpu.py
     Functions (11):
       â€¢ weno5_reconstruction_kernel
       â€¢ apply_weno_boundary_conditions_kernel
       â€¢ compute_flux_divergence_weno_kernel
       â€¢ calculate_spatial_discretization_weno_gpu
       â€¢ _create_weno_flux_kernel
       â€¢ compute_weno_fluxes_kernel
       â€¢ _primitives_to_conserved_gpu_device
       â€¢ _central_upwind_flux_gpu_device
       â€¢ calculate_spatial_discretization_weno_gpu_native
       â€¢ _compute_weno_fluxes_kernel
       â€¢ _compute_flux_divergence_weno_kernel

  ğŸ“„ riemann_solvers.py
     Functions (6):
       â€¢ set_current_time
       â€¢ central_upwind_flux
       â€¢ godunov_flux_upwind
       â€¢ _central_upwind_flux_cuda
       â€¢ central_upwind_flux_cuda_kernel
       â€¢ central_upwind_flux_gpu

  ğŸ“„ time_integration.py
     Functions (35):
       â€¢ _apply_bounds_kernel
       â€¢ apply_physical_state_bounds_gpu
       â€¢ apply_physical_state_bounds
       â€¢ check_cfl_condition
       â€¢ calculate_spatial_discretization_weno
       â€¢ calculate_spatial_discretization_godunov
       â€¢ primitives_to_conserved_single
       â€¢ _ode_rhs
       â€¢ _ode_rhs_corrected
       â€¢ solve_ode_step_cpu
       â€¢ _ode_step_kernel
       â€¢ solve_ode_step_gpu
       â€¢ compute_boundary_correction
       â€¢ compute_boundary_weight
       â€¢ apply_inflow_bc_manually
       â€¢ strang_splitting_step
       â€¢ strang_splitting_step_gpu
       â€¢ solve_hyperbolic_step_ssprk3
       â€¢ apply_temporal_update_ssprk3
       â€¢ compute_flux_divergence_first_order
       â€¢ solve_hyperbolic_step_gpu
       â€¢ solve_hyperbolic_step_weno_gpu
       â€¢ solve_hyperbolic_step_ssprk3_gpu
       â€¢ compute_spatial_discretization_gpu_callback
       â€¢ calculate_spatial_discretization_weno_gpu
       â€¢ _apply_euler_update_kernel
       â€¢ _transpose_physical_cells_kernel
       â€¢ _extract_physical_cells_kernel
       â€¢ _extract_physical_cells_to_format_kernel
       â€¢ _insert_physical_cells_from_format_kernel
       â€¢ _compute_flux_divergence_kernel
       â€¢ _apply_density_floor_kernel
       â€¢ strang_splitting_step_with_network
       â€¢ solve_hyperbolic_step_standard
       â€¢ solve_hyperbolic_step_standard_gpu

ğŸ“ arz_model/config/ (14 modules)
--------------------------------------------------------------------------------

  ğŸ“„ __init__.py

  ğŸ“„ bc_config.py
     Classes (8):
       â€¢ BCType
       â€¢ BCState
       â€¢ BCScheduleItem
       â€¢ InflowBC
       â€¢ OutflowBC
       â€¢ PeriodicBC
       â€¢ ReflectiveBC
       â€¢ BoundaryConditionsConfig
     Functions (1):
       â€¢ to_array

  ğŸ“„ builders.py
     Classes (2):
       â€¢ ConfigBuilder
       â€¢ RLNetworkConfigBuilder
     Functions (5):
       â€¢ section_7_6
       â€¢ simple_test
       â€¢ simple_corridor
       â€¢ medium_network
       â€¢ lagos_network

  ğŸ“„ config_base.yml

  ğŸ“„ debug_config.py

  ğŸ“„ grid_config.py
     Classes (1):
       â€¢ GridConfig

  ğŸ“„ ic_config.py
     Classes (6):
       â€¢ UniformIC
       â€¢ UniformEquilibriumIC
       â€¢ RiemannIC
       â€¢ GaussianPulseIC
       â€¢ FileBasedIC
       â€¢ ICConfig

  ğŸ“„ network_config.py
     Classes (2):
       â€¢ NetworkConfigError
       â€¢ NetworkConfig
     Functions (9):
       â€¢ __init__
       â€¢ load_from_files
       â€¢ _validate_network_schema
       â€¢ _validate_segment
       â€¢ _validate_node
       â€¢ _validate_link
       â€¢ _validate_traffic_control_schema
       â€¢ _validate_traffic_light
       â€¢ load_network_config

  ğŸ“„ network_simulation_config.py
     Classes (4):
       â€¢ SegmentConfig
       â€¢ NodeConfig
       â€¢ LinkConfig
       â€¢ NetworkSimulationConfig
     Functions (8):
       â€¢ validate_x_max
       â€¢ validate_N
       â€¢ validate_type
       â€¢ validate_position
       â€¢ validate_traffic_light_config
       â€¢ validate_boundary_condition
       â€¢ validate_coupling_type
       â€¢ validate_links

  ğŸ“„ physics_config.py
     Classes (1):
       â€¢ PhysicsConfig
     Functions (1):
       â€¢ __repr__

  ğŸ“„ scenario_convergence_test.yml

  ğŸ“„ scenario_junction_test.yml

  ğŸ“„ simulation_config.py
     Classes (1):
       â€¢ SimulationConfig
     Functions (1):
       â€¢ __repr__

  ğŸ“„ time_config.py
     Classes (1):
       â€¢ TimeConfig
     Functions (1):
       â€¢ output_dt_must_be_less_than_t_final

ğŸ“ arz_model/data/ (1 modules)
--------------------------------------------------------------------------------

  ğŸ“„ fichier_de_travail_corridor_utf8.csv

ğŸ“ arz_model/io/ (2 modules)
--------------------------------------------------------------------------------

  ğŸ“„ __init__.py

  ğŸ“„ data_manager.py
     Functions (5):
       â€¢ save_simulation_data
       â€¢ load_simulation_data
       â€¢ load_yaml_config
       â€¢ load_road_quality_file
       â€¢ save_mass_data

ğŸ“ arz_model/network/ (7 modules)
--------------------------------------------------------------------------------

  ğŸ“„ __init__.py

  ğŸ“„ junction_info.py
     Classes (1):
       â€¢ JunctionInfo
     Functions (3):
       â€¢ __post_init__
       â€¢ __str__
       â€¢ __repr__

  ğŸ“„ link.py
     Classes (1):
       â€¢ Link
     Functions (4):
       â€¢ __init__
       â€¢ apply_coupling
       â€¢ get_coupling_strength
       â€¢ __repr__

  ğŸ“„ network_grid.py
     Classes (1):
       â€¢ NetworkGrid
     Functions (8):
       â€¢ __init__
       â€¢ initialize
       â€¢ add_segment
       â€¢ add_node
       â€¢ add_link
       â€¢ _prepare_junction_info
       â€¢ _apply_network_boundary_conditions
       â€¢ step

  ğŸ“„ network_simulator.py
     Classes (2):
       â€¢ SimulationState
       â€¢ NetworkGridSimulator
     Functions (10):
       â€¢ __init__
       â€¢ reset
       â€¢ set_signal
       â€¢ step
       â€¢ get_metrics
       â€¢ health
       â€¢ compute_adaptive_dt
       â€¢ _build_network_from_config_simple
       â€¢ _apply_initial_conditions
       â€¢ _build_state

  ğŸ“„ node.py
     Classes (1):
       â€¢ Node
     Functions (7):
       â€¢ __init__
       â€¢ get_incoming_states
       â€¢ get_outgoing_capacities
       â€¢ is_signalized
       â€¢ get_traffic_light_state
       â€¢ update_traffic_lights
       â€¢ __repr__

  ğŸ“„ topology.py
     Functions (6):
       â€¢ build_graph
       â€¢ validate_topology
       â€¢ find_upstream_segments
       â€¢ find_downstream_segments
       â€¢ compute_shortest_path
       â€¢ get_network_diameter

ğŸ“ arz_model/road_network/ (4 modules)
--------------------------------------------------------------------------------

  ğŸ“„ __init__.py

  ğŸ“„ builder.py
     Functions (1):
       â€¢ build_simulation_network

  ğŸ“„ models.py
     Classes (4):
       â€¢ Node
       â€¢ Link
       â€¢ RoadNetwork
       â€¢ Config

  ğŸ“„ parser.py
     Functions (1):
       â€¢ parse_csv_to_road_network

ğŸ“ arz_model/root/ (5 modules)
--------------------------------------------------------------------------------

  ğŸ“„ README.md

  ğŸ“„ __init__.py

  ğŸ“„ main_network_builder.py
     Functions (1):
       â€¢ main

  ğŸ“„ main_network_simulation.py
     Functions (1):
       â€¢ main

  ğŸ“„ main_simulation.py
     Functions (1):
       â€¢ main

ğŸ“ arz_model/simulation/ (11 modules)
--------------------------------------------------------------------------------

  ğŸ“„ __init__.py

  ğŸ“„ __init__.py

  ğŸ“„ bc_controller.py
     Classes (1):
       â€¢ BCController
     Functions (7):
       â€¢ __init__
       â€¢ _convert_bc_config_to_dict
       â€¢ _convert_schedule
       â€¢ _initialize_schedules
       â€¢ _update_bc_from_schedule
       â€¢ apply
       â€¢ create_from_legacy_dict

  ğŸ“„ __init__.py

  ğŸ“„ network_simulator.py
     Classes (1):
       â€¢ NetworkSimulator
     Functions (3):
       â€¢ __init__
       â€¢ run
       â€¢ _log_state

  ğŸ“„ initial_conditions.py
     Functions (5):
       â€¢ uniform_state
       â€¢ uniform_state_from_equilibrium
       â€¢ riemann_problem
       â€¢ density_hump
       â€¢ sine_wave_perturbation

  ğŸ“„ __init__.py

  ğŸ“„ ic_builder.py
     Classes (1):
       â€¢ ICBuilder
     Functions (2):
       â€¢ build
       â€¢ build_from_legacy_dict

  ğŸ“„ runner.py
     Classes (1):
       â€¢ SimulationRunner
     Functions (24):
       â€¢ __init__
       â€¢ _init_from_network_grid
       â€¢ _init_from_pydantic
       â€¢ _resolve_device
       â€¢ _init_from_network_config
       â€¢ _init_from_network_config
       â€¢ _init_from_yaml
       â€¢ _create_legacy_params_from_config
       â€¢ _convert_ic_to_legacy
       â€¢ _convert_bc_to_legacy
       â€¢ _common_initialization
       â€¢ _initialize_network
       â€¢ _load_road_quality
       â€¢ _load_network_v0_overrides
       â€¢ _create_initial_state
       â€¢ _initialize_boundary_conditions
       â€¢ _update_bc_from_schedule
       â€¢ run
       â€¢ step
       â€¢ get_results
       â€¢ save_results
       â€¢ plot_results
       â€¢ animate_results
       â€¢ __repr__

  ğŸ“„ __init__.py

  ğŸ“„ state_manager.py
     Classes (1):
       â€¢ StateManager
     Functions (10):
       â€¢ __init__
       â€¢ get_current_state
       â€¢ update_state
       â€¢ advance_time
       â€¢ store_output
       â€¢ _update_mass_tracking
       â€¢ sync_from_gpu
       â€¢ sync_to_gpu
       â€¢ get_results
       â€¢ print_mass_conservation_summary

ğŸ“ arz_model/visualization/ (4 modules)
--------------------------------------------------------------------------------

  ğŸ“„ __init__.py

  ğŸ“„ network_visualizer.py
     Classes (1):
       â€¢ NetworkVisualizer
     Functions (9):
       â€¢ __init__
       â€¢ _create_graph_from_network
       â€¢ _draw_base_network
       â€¢ _update_plot_from_state
       â€¢ create_animation
       â€¢ animate
       â€¢ update_plot
       â€¢ add_colorbar
       â€¢ close

  ğŸ“„ plotting.py
     Functions (3):
       â€¢ plot_profiles
       â€¢ plot_spacetime
       â€¢ plot_convergence_loglog

  ğŸ“„ uxsim_adapter.py
     Classes (1):
       â€¢ ARZtoUXsimVisualizer
     Functions (5):
       â€¢ __init__
       â€¢ create_uxsim_network
       â€¢ visualize_snapshot
       â€¢ create_animation
       â€¢ update_frame

================================================================================
ğŸ“‹ EXISTING GPU CODE:
================================================================================

  ğŸ“„ arz_model/numerics/gpu/ssp_rk3_cuda.py
     â€¢ 1 classes
     â€¢ 8 functions
     Functions:
       - ssp_rk3_stage1_kernel
       - ssp_rk3_stage2_kernel
       - ssp_rk3_stage3_kernel
       - compute_flux_divergence_kernel
       - __init__
       - integrate_step
       - cleanup
       - integrate_ssp_rk3_gpu

  ğŸ“„ arz_model/numerics/gpu/utils.py
     â€¢ 1 classes
     â€¢ 10 functions
     Functions:
       - check_cuda_availability
       - get_optimal_block_size
       - profile_gpu_kernel
       - validate_gpu_vs_cpu
       - __init__
       - allocate_device_array
       - get_current_memory_usage
       - get_memory_stats
       - cleanup
       - benchmark_weno_implementations

  ğŸ“„ arz_model/numerics/gpu/weno_cuda.py
     â€¢ 0 classes
     â€¢ 5 functions
     Functions:
       - weno5_reconstruction_naive_kernel
       - apply_boundary_conditions_kernel
       - reconstruct_weno5_gpu_naive
       - weno5_reconstruction_optimized_kernel
       - reconstruct_weno5_gpu_optimized

  ğŸ“„ arz_model/numerics/gpu/__init__.py
     â€¢ 0 classes
     â€¢ 0 functions

================================================================================

================================================================================
ğŸ”— FUNCTION CALL GRAPH ANALYSIS
================================================================================

Total dependencies in arz_model: 246
ğŸ”¬ DEBUG: After building call graph, calls_to has 173 entries
ğŸ”¬ DEBUG: called_by has 138 entries

âš ï¸  DEAD CODE DETECTED:
   Functions never called: 167

   Dead functions (candidates for removal):

   ğŸ“„ arz_model/config/builders.py
      âš ï¸  lagos_network
      âš ï¸  medium_network
      âš ï¸  simple_corridor
      âš ï¸  simple_test

   ğŸ“„ arz_model/config/network_config.py
      âš ï¸  _validate_link
      âš ï¸  _validate_network_schema
      âš ï¸  _validate_node
      âš ï¸  _validate_segment
      âš ï¸  _validate_traffic_control_schema
      âš ï¸  _validate_traffic_light
      âš ï¸  load_network_config

   ğŸ“„ arz_model/config/network_simulation_config.py
      âš ï¸  validate_coupling_type
      âš ï¸  validate_links
      âš ï¸  validate_type
      âš ï¸  validate_x_max

   ğŸ“„ arz_model/config/time_config.py
      âš ï¸  output_dt_must_be_less_than_t_final

   ğŸ“„ arz_model/core/intersection.py
      âš ï¸  apply_creeping
      âš ï¸  get_creeping_speed
      âš ï¸  get_outgoing_capacity
      âš ï¸  get_queue_info
      âš ï¸  update_queues

   ğŸ“„ arz_model/core/node_solver.py
      âš ï¸  _apply_behavioral_coupling
      âš ï¸  _calculate_outgoing_flux
      âš ï¸  _get_default_flux
      âš ï¸  apply_priority_rules
      âš ï¸  update_node_queues

   ğŸ“„ arz_model/core/parameter_manager.py
      âš ï¸  get_all
      âš ï¸  has_local
      âš ï¸  list_segments_with_overrides
      âš ï¸  set_local
      âš ï¸  set_local_dict
      âš ï¸  summary

   ğŸ“„ arz_model/core/parameters.py
      âš ï¸  _validate_parameters

   ğŸ“„ arz_model/core/physics.py
      âš ï¸  _calculate_physical_velocity_cuda
      âš ï¸  _calculate_pressure_cuda
      âš ï¸  calculate_eigenvalues
      âš ï¸  calculate_equilibrium_speed
      âš ï¸  calculate_equilibrium_speed_gpu
      âš ï¸  calculate_physical_velocity
      âš ï¸  calculate_relaxation_time_gpu
      âš ï¸  calculate_source_term
      âš ï¸  calculate_source_term_gpu

   ğŸ“„ arz_model/core/traffic_lights.py
      âš ï¸  adapt_traffic_lights
      âš ï¸  get_phase_progress
      âš ï¸  set_offset

   ğŸ“„ arz_model/grid/grid1d.py
      âš ï¸  load_road_quality

   ğŸ“„ arz_model/io/data_manager.py
      âš ï¸  load_yaml_config
      âš ï¸  save_mass_data
      âš ï¸  save_simulation_data

   ğŸ“„ arz_model/main_simulation.py
      âš ï¸  main

   ğŸ“„ arz_model/network/link.py
      âš ï¸  apply_coupling
      âš ï¸  get_coupling_strength

   ğŸ“„ arz_model/network/network_grid.py
      âš ï¸  _prepare_junction_info
      âš ï¸  add_link
      âš ï¸  initialize

   ğŸ“„ arz_model/network/network_simulator.py
      âš ï¸  _apply_initial_conditions
      âš ï¸  _build_network_from_config_simple
      âš ï¸  _build_state
      âš ï¸  get_metrics
      âš ï¸  set_signal

   ğŸ“„ arz_model/network/node.py
      âš ï¸  get_incoming_states
      âš ï¸  get_outgoing_capacities
      âš ï¸  is_signalized

   ğŸ“„ arz_model/network/topology.py
      âš ï¸  compute_shortest_path
      âš ï¸  find_downstream_segments
      âš ï¸  find_upstream_segments
      âš ï¸  get_network_diameter

   ğŸ“„ arz_model/numerics/boundary_conditions.py
      âš ï¸  _apply_boundary_conditions_kernel

   ğŸ“„ arz_model/numerics/cfl.py
      âš ï¸  _calculate_max_wavespeed_kernel
      âš ï¸  calculate_cfl_dt

   ğŸ“„ arz_model/numerics/checkpoint_manager.py
      âš ï¸  detect_instability
      âš ï¸  print_statistics
      âš ï¸  reset_consecutive_rollbacks
      âš ï¸  should_checkpoint

   ğŸ“„ arz_model/numerics/gpu/ssp_rk3_cuda.py
      âš ï¸  compute_flux_divergence_kernel
      âš ï¸  integrate_step
      âš ï¸  ssp_rk3_stage1_kernel
      âš ï¸  ssp_rk3_stage2_kernel
      âš ï¸  ssp_rk3_stage3_kernel

   ğŸ“„ arz_model/numerics/gpu/utils.py
      âš ï¸  check_cuda_availability
      âš ï¸  get_optimal_block_size
      âš ï¸  profile_gpu_kernel
      âš ï¸  validate_gpu_vs_cpu

   ğŸ“„ arz_model/numerics/gpu/weno_cuda.py
      âš ï¸  apply_boundary_conditions_kernel
      âš ï¸  reconstruct_weno5_gpu_naive
      âš ï¸  reconstruct_weno5_gpu_optimized
      âš ï¸  weno5_reconstruction_naive_kernel
      âš ï¸  weno5_reconstruction_optimized_kernel

   ğŸ“„ arz_model/numerics/logging_utils.py
      âš ï¸  should_log

   ğŸ“„ arz_model/numerics/network_coupling_corrected.py
      âš ï¸  _apply_physical_boundary_conditions
      âš ï¸  _collect_real_boundary_states
      âš ï¸  _solve_node_conservation
      âš ï¸  _update_node_state
      âš ï¸  apply_network_coupling_cpu_corrected

   ğŸ“„ arz_model/numerics/reconstruction/converter.py
      âš ï¸  conserved_to_primitives_arr
      âš ï¸  conserved_to_primitives_arr_gpu
      âš ï¸  primitives_to_conserved_arr
      âš ï¸  primitives_to_conserved_arr_gpu

   ğŸ“„ arz_model/numerics/reconstruction/weno.py
      âš ï¸  reconstruct_weno5

   ğŸ“„ arz_model/numerics/reconstruction/weno_gpu.py
      âš ï¸  _central_upwind_flux_gpu_device
      âš ï¸  _compute_flux_divergence_weno_kernel
      âš ï¸  _compute_weno_fluxes_kernel
      âš ï¸  _create_weno_flux_kernel
      âš ï¸  _primitives_to_conserved_gpu_device
      âš ï¸  apply_weno_boundary_conditions_kernel
      âš ï¸  weno5_reconstruction_kernel

   ğŸ“„ arz_model/numerics/riemann_solvers.py
      âš ï¸  _central_upwind_flux_cuda
      âš ï¸  central_upwind_flux_cuda_kernel
      âš ï¸  central_upwind_flux_gpu
      âš ï¸  godunov_flux_upwind
      âš ï¸  set_current_time

   ğŸ“„ arz_model/numerics/time_integration.py
      âš ï¸  _apply_bounds_kernel
      âš ï¸  _apply_density_floor_kernel
      âš ï¸  _apply_euler_update_kernel
      âš ï¸  _ode_rhs
      âš ï¸  _ode_rhs_corrected
      âš ï¸  _ode_step_kernel
      âš ï¸  _transpose_physical_cells_kernel
      âš ï¸  apply_inflow_bc_manually
      âš ï¸  apply_physical_state_bounds
      âš ï¸  apply_physical_state_bounds_gpu
      âš ï¸  apply_temporal_update_ssprk3
      âš ï¸  calculate_spatial_discretization_godunov
      âš ï¸  calculate_spatial_discretization_weno
      âš ï¸  check_cfl_condition
      âš ï¸  compute_boundary_correction
      âš ï¸  compute_boundary_weight
      âš ï¸  compute_flux_divergence_first_order
      âš ï¸  compute_spatial_discretization_gpu_callback
      âš ï¸  primitives_to_conserved_single
      âš ï¸  solve_hyperbolic_step_gpu
      âš ï¸  solve_hyperbolic_step_standard
      âš ï¸  solve_ode_step_cpu
      âš ï¸  solve_ode_step_gpu
      âš ï¸  strang_splitting_step
      âš ï¸  strang_splitting_step_gpu

   ğŸ“„ arz_model/road_network/builder.py
      âš ï¸  build_simulation_network

   ğŸ“„ arz_model/road_network/parser.py
      âš ï¸  parse_csv_to_road_network

   ğŸ“„ arz_model/simulation/boundaries/bc_controller.py
      âš ï¸  apply
      âš ï¸  create_from_legacy_dict

   ğŸ“„ arz_model/simulation/execution/network_simulator.py
      âš ï¸  _log_state

   ğŸ“„ arz_model/simulation/initial_conditions.py
      âš ï¸  density_hump
      âš ï¸  riemann_problem
      âš ï¸  sine_wave_perturbation
      âš ï¸  uniform_state_from_equilibrium

   ğŸ“„ arz_model/simulation/initialization/ic_builder.py
      âš ï¸  build
      âš ï¸  build_from_legacy_dict

   ğŸ“„ arz_model/simulation/runner.py
      âš ï¸  _convert_bc_to_legacy
      âš ï¸  _convert_ic_to_legacy
      âš ï¸  _create_initial_state
      âš ï¸  _init_from_network_grid
      âš ï¸  _init_from_pydantic
      âš ï¸  _initialize_boundary_conditions
      âš ï¸  _initialize_network
      âš ï¸  animate_results
      âš ï¸  save_results
      âš ï¸  step

   ğŸ“„ arz_model/simulation/state/state_manager.py
      âš ï¸  _update_mass_tracking
      âš ï¸  get_current_state
      âš ï¸  print_mass_conservation_summary

   ğŸ“„ arz_model/visualization/network_visualizer.py
      âš ï¸  _draw_base_network
      âš ï¸  update_plot

   ğŸ“„ arz_model/visualization/plotting.py
      âš ï¸  plot_convergence_loglog
      âš ï¸  plot_profiles
      âš ï¸  plot_spacetime

   ğŸ“„ arz_model/visualization/uxsim_adapter.py
      âš ï¸  update_frame
      âš ï¸  visualize_snapshot


ğŸš€ ENTRY POINTS (main/run functions):
   Found 0 entry points


ğŸ“Š WORKFLOW CALL CHAIN ANALYSIS
================================================================================
Analyzing function call chains by category (GPU, time integration, WENO, etc.)
Focus: Identify redundancy, unification opportunities, refactoring targets
================================================================================

ğŸ” Function Classification:
  - GPU functions: 64
  - Time integration functions: 11
  - WENO reconstruction functions: 21
  - Riemann/Flux functions: 21
  - Physics functions: 16
  - Boundary condition functions: 22

ğŸ”¬ DEBUG: calls_to dictionary has 173 entries
ğŸ”¬ DEBUG: Sample calls_to keys: ['fn:arz_model/config/network_config.py#__init__@50', 'fn:arz_model/config/network_config.py#load_network_config@331', 'fn:arz_model/config/network_simulation_config.py#validate_x_max@59', 'fn:arz_model/config/network_simulation_config.py#validate_type@129', 'fn:arz_model/config/network_simulation_config.py#validate_position@138']
ğŸ”¬ DEBUG: Sample GPU function IDs: ['fn:arz_model/numerics/time_integration.py#_extract_physical_cells_kernel@1823', 'fn:arz_model/numerics/gpu/ssp_rk3_cuda.py#__init__@103', 'fn:arz_model/numerics/time_integration.py#solve_hyperbolic_step_gpu@1573']

================================================================================
ğŸš€ GPU WORKFLOWS
================================================================================

Found 23 functions with dependencies
Analyzing top 5 most connected functions:


ğŸ“ cleanup (ssp_rk3_cuda)
   Calls 2 other functions directly
   Complete call tree: 4 functions

   â–¶ cleanup (ssp_rk3_cuda)
     â””â”€ cleanup (utils)
       â””â”€ benchmark_weno_implementations (utils)
     â””â”€ integrate_ssp_rk3_gpu (ssp_rk3_cuda)

#### cleanup - Mermaid Diagram
```mermaid
graph TD
    N0["cleanup<br/>(ssp_rk3_cuda)"]
    N1["cleanup<br/>(utils)"]
    N2["benchmark_weno_implementations<br/>(utils)"]
    N3["integrate_ssp_rk3_gpu<br/>(ssp_rk3_cuda)"]
    N0 --> N1
    N0 --> N3
    N1 --> N0
    N1 --> N2
```

ğŸ“ sync_from_gpu (state_manager)
   Calls 2 other functions directly
   Complete call tree: 4 functions

   â–¶ sync_from_gpu (state_manager)
     â””â”€ sync_to_gpu (state_manager)
       â””â”€ get_results (runner)
         â””â”€ get_results (state_manager)

#### sync_from_gpu - Mermaid Diagram
```mermaid
graph TD
    N0["sync_from_gpu<br/>(state_manager)"]
    N1["sync_to_gpu<br/>(state_manager)"]
    N2["get_results<br/>(runner)"]
    N3["get_results<br/>(state_manager)"]
    N0 --> N1
    N0 --> N2
    N1 --> N2
    N1 --> N0
    N2 --> N3
    N3 --> N2
    N3 --> N0
```

ğŸ“ solve_hyperbolic_step_standard_gpu (time_integration)
   Calls 2 other functions directly
   Complete call tree: 4 functions

   â–¶ solve_hyperbolic_step_standard_gpu (time_integration)
     â””â”€ solve_hyperbolic_step_ssprk3_gpu (time_integration)
       â””â”€ solve_hyperbolic_step_ssprk3 (time_integration)
     â””â”€ solve_hyperbolic_step_weno_gpu (time_integration)

#### solve_hyperbolic_step_standard_gpu - Mermaid Diagram
```mermaid
graph TD
    N0["solve_hyperbolic_step_standard_gpu<br/>(time_integration)"]
    N1["solve_hyperbolic_step_ssprk3_gpu<br/>(time_integration)"]
    N2["solve_hyperbolic_step_ssprk3<br/>(time_integration)"]
    N3["solve_hyperbolic_step_weno_gpu<br/>(time_integration)"]
    N0 --> N1
    N0 --> N3
    N1 --> N2
    N3 --> N1
```

ğŸ“ sync_to_gpu (state_manager)
   Calls 2 other functions directly
   Complete call tree: 4 functions

   â–¶ sync_to_gpu (state_manager)
     â””â”€ get_results (runner)
       â””â”€ get_results (state_manager)
         â””â”€ sync_from_gpu (state_manager)

#### sync_to_gpu - Mermaid Diagram
```mermaid
graph TD
    N0["sync_to_gpu<br/>(state_manager)"]
    N1["get_results<br/>(runner)"]
    N2["get_results<br/>(state_manager)"]
    N3["sync_from_gpu<br/>(state_manager)"]
    N0 --> N1
    N0 --> N3
    N1 --> N2
    N2 --> N1
    N2 --> N3
    N3 --> N0
    N3 --> N1
```

ğŸ“ _extract_physical_cells_kernel (time_integration)
   Calls 1 other functions directly
   Complete call tree: 4 functions

   â–¶ _extract_physical_cells_kernel (time_integration)
     â””â”€ _extract_physical_cells_to_format_kernel (time_integration)
       â””â”€ _insert_physical_cells_from_format_kernel (time_integration)
         â””â”€ _compute_flux_divergence_kernel (time_integration)

#### _extract_physical_cells_kernel - Mermaid Diagram
```mermaid
graph TD
    N0["_extract_physical_cells_kernel<br/>(time_integration)"]
    N1["_extract_physical_cells_to_forma...<br/>(time_integration)"]
    N2["_insert_physical_cells_from_form...<br/>(time_integration)"]
    N3["_compute_flux_divergence_kernel<br/>(time_integration)"]
    N0 --> N1
    N1 --> N2
    N2 --> N3
```

================================================================================
â±ï¸  TIME INTEGRATION WORKFLOWS
================================================================================

Found 3 functions with dependencies
Analyzing top 3 most connected functions:


ğŸ“ cleanup (ssp_rk3_cuda)
   Calls 2 other functions directly
   Complete call tree: 4 functions

   â–¶ cleanup (ssp_rk3_cuda)
     â””â”€ cleanup (utils)
       â””â”€ benchmark_weno_implementations (utils)
     â””â”€ integrate_ssp_rk3_gpu (ssp_rk3_cuda)

#### cleanup - Mermaid Diagram
```mermaid
graph TD
    N0["cleanup<br/>(ssp_rk3_cuda)"]
    N1["cleanup<br/>(utils)"]
    N2["benchmark_weno_implementations<br/>(utils)"]
    N3["integrate_ssp_rk3_gpu<br/>(ssp_rk3_cuda)"]
    N0 --> N1
    N0 --> N3
    N1 --> N0
    N1 --> N2
```

ğŸ“ __init__ (ssp_rk3_cuda)
   Calls 1 other functions directly
   Complete call tree: 4 functions

   â–¶ __init__ (ssp_rk3_cuda)
     â””â”€ __init__ (network_config)
       â””â”€ __init__ (intersection)
       â””â”€ load_from_files (network_config)

#### __init__ - Mermaid Diagram
```mermaid
graph TD
    N0["__init__<br/>(ssp_rk3_cuda)"]
    N1["__init__<br/>(network_config)"]
    N2["__init__<br/>(intersection)"]
    N3["load_from_files<br/>(network_config)"]
    N0 --> N1
    N1 --> N2
    N1 --> N3
    N2 --> N1
```

ğŸ“ solve_hyperbolic_step_ssprk3_gpu (time_integration)
   Calls 1 other functions directly
   Complete call tree: 2 functions

   â–¶ solve_hyperbolic_step_ssprk3_gpu (time_integration)
     â””â”€ solve_hyperbolic_step_ssprk3 (time_integration)

#### solve_hyperbolic_step_ssprk3_gpu - Mermaid Diagram
```mermaid
graph TD
    N0["solve_hyperbolic_step_ssprk3_gpu<br/>(time_integration)"]
    N1["solve_hyperbolic_step_ssprk3<br/>(time_integration)"]
    N0 --> N1
```

================================================================================
ğŸ“ WENO RECONSTRUCTION WORKFLOWS
================================================================================

Found 6 functions with dependencies
Analyzing top 5 most connected functions:


ğŸ“ solve_hyperbolic_step_weno_gpu (time_integration)
   Calls 1 other functions directly
   Complete call tree: 3 functions

   â–¶ solve_hyperbolic_step_weno_gpu (time_integration)
     â””â”€ solve_hyperbolic_step_ssprk3_gpu (time_integration)
       â””â”€ solve_hyperbolic_step_ssprk3 (time_integration)

#### solve_hyperbolic_step_weno_gpu - Mermaid Diagram
```mermaid
graph TD
    N0["solve_hyperbolic_step_weno_gpu<br/>(time_integration)"]
    N1["solve_hyperbolic_step_ssprk3_gpu<br/>(time_integration)"]
    N2["solve_hyperbolic_step_ssprk3<br/>(time_integration)"]
    N0 --> N1
    N1 --> N2
```

ğŸ“ calculate_spatial_discretization_weno_gpu (time_integration)
   Calls 1 other functions directly
   Complete call tree: 2 functions

   â–¶ calculate_spatial_discretization_weno_gpu (time_integration)
     â””â”€ calculate_spatial_discretization_weno_gpu (weno_gpu)

#### calculate_spatial_discretization_weno_gpu - Mermaid Diagram
```mermaid
graph TD
    N0["calculate_spatial_discretization...<br/>(time_integration)"]
    N1["calculate_spatial_discretization...<br/>(weno_gpu)"]
    N0 --> N1
    N1 --> N0
```

ğŸ“ calculate_spatial_discretization_weno_gpu (weno_gpu)
   Calls 1 other functions directly
   Complete call tree: 2 functions

   â–¶ calculate_spatial_discretization_weno_gpu (weno_gpu)
     â””â”€ calculate_spatial_discretization_weno_gpu (time_integration)

#### calculate_spatial_discretization_weno_gpu - Mermaid Diagram
```mermaid
graph TD
    N0["calculate_spatial_discretization...<br/>(weno_gpu)"]
    N1["calculate_spatial_discretization...<br/>(time_integration)"]
    N0 --> N1
    N1 --> N0
```

ğŸ“ _create_weno_flux_kernel (weno_gpu)
   Calls 1 other functions directly
   Complete call tree: 2 functions

   â–¶ _create_weno_flux_kernel (weno_gpu)
     â””â”€ compute_weno_fluxes_kernel (weno_gpu)

#### _create_weno_flux_kernel - Mermaid Diagram
```mermaid
graph TD
    N0["_create_weno_flux_kernel<br/>(weno_gpu)"]
    N1["compute_weno_fluxes_kernel<br/>(weno_gpu)"]
    N0 --> N1
```

ğŸ“ apply_weno_boundary_conditions_kernel (weno_gpu)
   Calls 1 other functions directly
   Complete call tree: 2 functions

   â–¶ apply_weno_boundary_conditions_kernel (weno_gpu)
     â””â”€ compute_flux_divergence_weno_kernel (weno_gpu)

#### apply_weno_boundary_conditions_kernel - Mermaid Diagram
```mermaid
graph TD
    N0["apply_weno_boundary_conditions_k...<br/>(weno_gpu)"]
    N1["compute_flux_divergence_weno_ker...<br/>(weno_gpu)"]
    N0 --> N1
```

================================================================================
ğŸŒŠ RIEMANN SOLVER / FLUX WORKFLOWS
================================================================================

Found 5 functions with dependencies
Analyzing top 5 most connected functions:


ğŸ“ compute_flux_divergence_first_order (time_integration)
   Calls 1 other functions directly
   Complete call tree: 2 functions

   â–¶ compute_flux_divergence_first_order (time_integration)
     â””â”€ apply_boundary_conditions (boundary_conditions)

#### compute_flux_divergence_first_order - Mermaid Diagram
```mermaid
graph TD
    N0["compute_flux_divergence_first_or...<br/>(time_integration)"]
    N1["apply_boundary_conditions<br/>(boundary_conditions)"]
    N0 --> N1
```

ğŸ“ _create_weno_flux_kernel (weno_gpu)
   Calls 1 other functions directly
   Complete call tree: 2 functions

   â–¶ _create_weno_flux_kernel (weno_gpu)
     â””â”€ compute_weno_fluxes_kernel (weno_gpu)

#### _create_weno_flux_kernel - Mermaid Diagram
```mermaid
graph TD
    N0["_create_weno_flux_kernel<br/>(weno_gpu)"]
    N1["compute_weno_fluxes_kernel<br/>(weno_gpu)"]
    N0 --> N1
```

ğŸ“ set_current_time (riemann_solvers)
   Calls 1 other functions directly
   Complete call tree: 2 functions

   â–¶ set_current_time (riemann_solvers)
     â””â”€ central_upwind_flux (riemann_solvers)

#### set_current_time - Mermaid Diagram
```mermaid
graph TD
    N0["set_current_time<br/>(riemann_solvers)"]
    N1["central_upwind_flux<br/>(riemann_solvers)"]
    N0 --> N1
```

ğŸ“ _central_upwind_flux_gpu_device (weno_gpu)
   Calls 1 other functions directly
   Complete call tree: 2 functions

   â–¶ _central_upwind_flux_gpu_device (weno_gpu)
     â””â”€ calculate_spatial_discretization_weno_gpu_native (weno_gpu)

#### _central_upwind_flux_gpu_device - Mermaid Diagram
```mermaid
graph TD
    N0["_central_upwind_flux_gpu_device<br/>(weno_gpu)"]
    N1["calculate_spatial_discretization...<br/>(weno_gpu)"]
    N0 --> N1
```

ğŸ“ _get_default_flux (node_solver)
   Calls 1 other functions directly
   Complete call tree: 2 functions

   â–¶ _get_default_flux (node_solver)
     â””â”€ solve_intersection_riemann (node_solver)

#### _get_default_flux - Mermaid Diagram
```mermaid
graph TD
    N0["_get_default_flux<br/>(node_solver)"]
    N1["solve_intersection_riemann<br/>(node_solver)"]
    N0 --> N1
```

================================================================================
âš›ï¸  PHYSICS WORKFLOWS
================================================================================

Found 5 functions with dependencies
Analyzing top 5 most connected functions:


ğŸ“ _calculate_physical_velocity_cuda (physics)
   Calls 1 other functions directly
   Complete call tree: 2 functions

   â–¶ _calculate_physical_velocity_cuda (physics)
     â””â”€ _calculate_pressure_derivative (physics)

#### _calculate_physical_velocity_cuda - Mermaid Diagram
```mermaid
graph TD
    N0["_calculate_physical_velocity_cuda<br/>(physics)"]
    N1["_calculate_pressure_derivative<br/>(physics)"]
    N0 --> N1
```

ğŸ“ _calculate_pressure_derivative_cuda (physics)
   Calls 1 other functions directly
   Complete call tree: 2 functions

   â–¶ _calculate_pressure_derivative_cuda (physics)
     â””â”€ _calculate_eigenvalues_cuda (physics)

#### _calculate_pressure_derivative_cuda - Mermaid Diagram
```mermaid
graph TD
    N0["_calculate_pressure_derivative_c...<br/>(physics)"]
    N1["_calculate_eigenvalues_cuda<br/>(physics)"]
    N0 --> N1
    N1 --> N0
```

ğŸ“ calculate_relaxation_time_gpu (physics)
   Calls 1 other functions directly
   Complete call tree: 2 functions

   â–¶ calculate_relaxation_time_gpu (physics)
     â””â”€ calculate_relaxation_time (physics)

#### calculate_relaxation_time_gpu - Mermaid Diagram
```mermaid
graph TD
    N0["calculate_relaxation_time_gpu<br/>(physics)"]
    N1["calculate_relaxation_time<br/>(physics)"]
    N0 --> N1
```

ğŸ“ __repr__ (physics_config)
   Calls 1 other functions directly
   Complete call tree: 2 functions

   â–¶ __repr__ (physics_config)
     â””â”€ __repr__ (simulation_config)

#### __repr__ - Mermaid Diagram
```mermaid
graph TD
    N0["__repr__<br/>(physics_config)"]
    N1["__repr__<br/>(simulation_config)"]
    N0 --> N1
    N1 --> N0
```

ğŸ“ _calculate_eigenvalues_cuda (physics)
   Calls 1 other functions directly
   Complete call tree: 2 functions

   â–¶ _calculate_eigenvalues_cuda (physics)
     â””â”€ _calculate_pressure_derivative_cuda (physics)

#### _calculate_eigenvalues_cuda - Mermaid Diagram
```mermaid
graph TD
    N0["_calculate_eigenvalues_cuda<br/>(physics)"]
    N1["_calculate_pressure_derivative_c...<br/>(physics)"]
    N0 --> N1
    N1 --> N0
```

================================================================================
ğŸš§ BOUNDARY CONDITION WORKFLOWS
================================================================================

Found 12 functions with dependencies
Analyzing top 5 most connected functions:


ğŸ“ __init__ (bc_controller)
   Calls 2 other functions directly
   Complete call tree: 10 functions

   â–¶ __init__ (bc_controller)
     â””â”€ __init__ (network_config)
       â””â”€ __init__ (intersection)
       â””â”€ load_from_files (network_config)
     â””â”€ _convert_bc_config_to_dict (bc_controller)
       â””â”€ _initialize_schedules (bc_controller)
         â””â”€ get (parameter_manager)
         â””â”€ _update_bc_from_schedule (bc_controller)
           â””â”€ _update_bc_from_schedule (runner)
       â””â”€ _convert_schedule (bc_controller)

#### __init__ - Mermaid Diagram
```mermaid
graph TD
    N0["__init__<br/>(bc_controller)"]
    N1["__init__<br/>(network_config)"]
    N2["__init__<br/>(intersection)"]
    N3["load_from_files<br/>(network_config)"]
    N4["_convert_bc_config_to_dict<br/>(bc_controller)"]
    N5["_initialize_schedules<br/>(bc_controller)"]
    N6["get<br/>(parameter_manager)"]
    N7["_update_bc_from_schedule<br/>(bc_controller)"]
    N8["_update_bc_from_schedule<br/>(runner)"]
    N9["_convert_schedule<br/>(bc_controller)"]
    N0 --> N1
    N0 --> N4
    N1 --> N2
    N1 --> N3
    N2 --> N1
    N4 --> N5
    N4 --> N9
    N5 --> N6
    N5 --> N7
    N7 --> N8
    N8 --> N7
    N9 --> N5
```

ğŸ“ _initialize_schedules (bc_controller)
   Calls 2 other functions directly
   Complete call tree: 4 functions

   â–¶ _initialize_schedules (bc_controller)
     â””â”€ get (parameter_manager)
     â””â”€ _update_bc_from_schedule (bc_controller)
       â””â”€ _update_bc_from_schedule (runner)

#### _initialize_schedules - Mermaid Diagram
```mermaid
graph TD
    N0["_initialize_schedules<br/>(bc_controller)"]
    N1["get<br/>(parameter_manager)"]
    N2["_update_bc_from_schedule<br/>(bc_controller)"]
    N3["_update_bc_from_schedule<br/>(runner)"]
    N0 --> N1
    N0 --> N2
    N2 --> N3
    N3 --> N2
```

ğŸ“ apply (bc_controller)
   Calls 2 other functions directly
   Complete call tree: 4 functions

   â–¶ apply (bc_controller)
     â””â”€ _update_bc_from_schedule (bc_controller)
       â””â”€ _update_bc_from_schedule (runner)
     â””â”€ apply_boundary_conditions (boundary_conditions)

#### apply - Mermaid Diagram
```mermaid
graph TD
    N0["apply<br/>(bc_controller)"]
    N1["_update_bc_from_schedule<br/>(bc_controller)"]
    N2["_update_bc_from_schedule<br/>(runner)"]
    N3["apply_boundary_conditions<br/>(boundary_conditions)"]
    N0 --> N1
    N0 --> N3
    N1 --> N2
    N2 --> N1
```

ğŸ“ _convert_bc_config_to_dict (bc_controller)
   Calls 2 other functions directly
   Complete call tree: 6 functions

   â–¶ _convert_bc_config_to_dict (bc_controller)
     â””â”€ _initialize_schedules (bc_controller)
       â””â”€ get (parameter_manager)
       â””â”€ _update_bc_from_schedule (bc_controller)
         â””â”€ _update_bc_from_schedule (runner)
     â””â”€ _convert_schedule (bc_controller)

#### _convert_bc_config_to_dict - Mermaid Diagram
```mermaid
graph TD
    N0["_convert_bc_config_to_dict<br/>(bc_controller)"]
    N1["_initialize_schedules<br/>(bc_controller)"]
    N2["get<br/>(parameter_manager)"]
    N3["_update_bc_from_schedule<br/>(bc_controller)"]
    N4["_update_bc_from_schedule<br/>(runner)"]
    N5["_convert_schedule<br/>(bc_controller)"]
    N0 --> N1
    N0 --> N5
    N1 --> N2
    N1 --> N3
    N3 --> N4
    N4 --> N3
    N5 --> N1
```

ğŸ“ _convert_schedule (bc_controller)
   Calls 1 other functions directly
   Complete call tree: 5 functions

   â–¶ _convert_schedule (bc_controller)
     â””â”€ _initialize_schedules (bc_controller)
       â””â”€ get (parameter_manager)
       â””â”€ _update_bc_from_schedule (bc_controller)
         â””â”€ _update_bc_from_schedule (runner)

#### _convert_schedule - Mermaid Diagram
```mermaid
graph TD
    N0["_convert_schedule<br/>(bc_controller)"]
    N1["_initialize_schedules<br/>(bc_controller)"]
    N2["get<br/>(parameter_manager)"]
    N3["_update_bc_from_schedule<br/>(bc_controller)"]
    N4["_update_bc_from_schedule<br/>(runner)"]
    N0 --> N1
    N1 --> N2
    N1 --> N3
    N3 --> N4
    N4 --> N3
```

================================================================================
ğŸ”§ REFACTORING INSIGHTS
================================================================================

1. POTENTIAL REDUNDANCIES (functions with similar call patterns):
--------------------------------------------------------------------------------

Group 1: 11 functions with identical call pattern:
  - __init__ (ssp_rk3_cuda)
  - __init__ (network_simulator)
  - __init__ (node)
  - __init__ (intersection)
  - __init__ (network_simulator)
  - __init__ (parameter_manager)
  - __init__ (network_grid)
  - __init__ (link)
  - is_yellow (traffic_lights)
  - __init__ (state_manager)
  - __init__ (grid1d)
  Common callees (1 functions):
    â†’ __init__ (network_config)

Group 2: 11 functions with identical call pattern:
  - _create_initial_state (runner)
  - _apply_initial_conditions (network_simulator)
  - create_traffic_light_from_config (traffic_lights)
  - _apply_network_boundary_conditions (network_grid)
  - update_node_queues (node_solver)
  - validate_topology (topology)
  - build_from_legacy_dict (ic_builder)
  - _update_plot_from_state (network_visualizer)
  - update_queues (intersection)
  - _initialize_boundary_conditions (runner)
  - clear_local (parameter_manager)
  Common callees (1 functions):
    â†’ get (parameter_manager)

Group 3: 5 functions with identical call pattern:
  - __repr__ (simulation_config)
  - __repr__ (link)
  - __repr__ (runner)
  - __repr__ (parameter_manager)
  - __repr__ (junction_info)
  Common callees (1 functions):
    â†’ __repr__ (physics_config)

Group 4: 3 functions with identical call pattern:
  - __str__ (grid1d)
  - __post_init__ (junction_info)
  - cell_interfaces (grid1d)
  Common callees (1 functions):
    â†’ __str__ (parameters)

Group 5: 3 functions with identical call pattern:
  - primitives_to_conserved_arr (converter)
  - primitives_to_conserved_single (time_integration)
  - conserved_to_primitives_arr (converter)
  Common callees (1 functions):
    â†’ calculate_pressure (physics)

Group 6: 2 functions with identical call pattern:
  - get_results (state_manager)
  - sync_to_gpu (state_manager)
  Common callees (2 functions):
    â†’ sync_from_gpu (state_manager)
    â†’ get_results (runner)

Group 7: 2 functions with identical call pattern:
  - main (main_network_simulation)
  - main (main_simulation)
  Common callees (1 functions):
    â†’ main (main_network_builder)

Group 8: 2 functions with identical call pattern:
  - _convert_schedule (bc_controller)
  - create_from_legacy_dict (bc_controller)
  Common callees (1 functions):
    â†’ _initialize_schedules (bc_controller)

Group 9: 2 functions with identical call pattern:
  - get_cycle_info (traffic_lights)
  - get_queue_info (intersection)
  Common callees (1 functions):
    â†’ reset_stats (intersection)

Group 10: 2 functions with identical call pattern:
  - update_traffic_lights (node)
  - __repr__ (node)
  Common callees (2 functions):
    â†’ update_stats (intersection)
    â†’ __repr__ (physics_config)


2. HUB FUNCTIONS (called by many others - candidates for unification):
--------------------------------------------------------------------------------
  __init__                                                     (network_config                ) - called by 25 functions
  get                                                          (parameter_manager             ) - called by 16 functions
  __repr__                                                     (physics_config                ) - called by 9 functions
  get_results                                                  (runner                        ) - called by 6 functions
  update_stats                                                 (intersection                  ) - called by 5 functions
  reset_stats                                                  (intersection                  ) - called by 4 functions
  get_config                                                   (intersection                  ) - called by 4 functions
  add_segment                                                  (intersection                  ) - called by 4 functions
  create_intersection_from_config                              (intersection                  ) - called by 4 functions
  __str__                                                      (parameters                    ) - called by 4 functions
  get_connected_segments                                       (intersection                  ) - called by 3 functions
  get_current_phase                                            (traffic_lights                ) - called by 3 functions
  _update_cycle_time                                           (traffic_lights                ) - called by 3 functions
  calculate_pressure                                           (physics                       ) - called by 3 functions
  _initialize_schedules                                        (bc_controller                 ) - called by 3 functions
  _update_bc_from_schedule                                     (bc_controller                 ) - called by 3 functions
  _update_plot_from_state                                      (network_visualizer            ) - called by 3 functions
  close                                                        (network_visualizer            ) - called by 3 functions
  load_from_files                                              (network_config                ) - called by 2 functions
  get_current_green_segments                                   (traffic_lights                ) - called by 2 functions
  remove_segment                                               (intersection                  ) - called by 2 functions
  load_from_yaml                                               (parameters                    ) - called by 2 functions
  remove_phase                                                 (traffic_lights                ) - called by 2 functions
  get_cycle_info                                               (traffic_lights                ) - called by 2 functions
  get_coordination_info                                        (traffic_lights                ) - called by 2 functions
  create_traffic_light_from_config                             (traffic_lights                ) - called by 2 functions
  main                                                         (main_network_builder          ) - called by 2 functions
  step                                                         (network_grid                  ) - called by 2 functions
  update_traffic_lights                                        (node                          ) - called by 2 functions
  build_graph                                                  (topology                      ) - called by 2 functions


3. LEAF FUNCTIONS (call nothing - pure computation, easy GPU kernel candidates):
--------------------------------------------------------------------------------
Found 52 leaf functions that are actually used:
  _enforce_mass_conservation                                   (network_coupling_corrected    ) - used by 1 functions
  validate_boundary_condition                                  (network_simulation_config     ) - used by 1 functions
  create_intersection_from_config                              (intersection                  ) - used by 4 functions
  cfl_condition                                                (cfl                           ) - used by 1 functions
  _load_network_v0_overrides                                   (runner                        ) - used by 1 functions
  _load_road_quality                                           (runner                        ) - used by 1 functions
  strang_splitting_step_with_network                           (time_integration              ) - used by 1 functions
  _common_initialization                                       (runner                        ) - used by 1 functions
  store_output                                                 (state_manager                 ) - used by 1 functions
  section_7_6                                                  (builders                      ) - used by 1 functions
  benchmark_weno_implementations                               (utils                         ) - used by 1 functions
  _create_legacy_params_from_config                            (runner                        ) - used by 1 functions
  reset                                                        (network_simulator             ) - used by 1 functions
  load_road_quality_file                                       (data_manager                  ) - used by 1 functions
  _calculate_pressure_derivative                               (physics                       ) - used by 1 functions
  validate_N                                                   (network_simulation_config     ) - used by 1 functions
  _compute_flux_divergence_kernel                              (time_integration              ) - used by 1 functions
  integrate_ssp_rk3_gpu                                        (ssp_rk3_cuda                  ) - used by 1 functions
  load_from_files                                              (network_config                ) - used by 2 functions
  load_from_pydantic                                           (parameters                    ) - used by 1 functions
  solve_intersection_riemann                                   (node_solver                   ) - used by 1 functions
  solve_node_fluxes                                            (node_solver                   ) - used by 1 functions
  calculate_optimal_cycle_time                                 (traffic_lights                ) - used by 1 functions
  apply_network_coupling                                       (network_coupling_corrected    ) - used by 2 functions
  central_upwind_flux                                          (riemann_solvers               ) - used by 1 functions
  close                                                        (network_visualizer            ) - used by 3 functions
  rollback                                                     (checkpoint_manager            ) - used by 1 functions
  build_graph                                                  (topology                      ) - used by 2 functions
  save_checkpoint                                              (checkpoint_manager            ) - used by 1 functions
  _build_segment_mapping                                       (network_coupling_corrected    ) - used by 1 functions
  calculate_relaxation_time                                    (physics                       ) - used by 1 functions
  get_time_to_next_phase                                       (traffic_lights                ) - used by 1 functions
  compute_weno_fluxes_kernel                                   (weno_gpu                      ) - used by 1 functions
  compute_adaptive_dt                                          (network_simulator             ) - used by 1 functions
  add_node                                                     (network_grid                  ) - used by 1 functions
  _deep_merge_dicts                                            (parameters                    ) - used by 1 functions
  get_statistics                                               (checkpoint_manager            ) - used by 2 functions
  to_array                                                     (bc_config                     ) - used by 1 functions
  apply_boundary_conditions                                    (boundary_conditions           ) - used by 2 functions
  compute_flux_divergence_weno_kernel                          (weno_gpu                      ) - used by 1 functions


4. GPU/CPU DUPLICATES (redundant implementations to unify):
--------------------------------------------------------------------------------
Found 13 GPU/CPU function pairs (candidates for unification):
  GPU: _calculate_pressure_derivative_cuda                <-> CPU: _calculate_pressure_derivative
  GPU: calculate_spatial_discretization_weno_gpu          <-> CPU: calculate_spatial_discretization_weno
  GPU: calculate_relaxation_time_gpu                      <-> CPU: calculate_relaxation_time
  GPU: primitives_to_conserved_arr_gpu                    <-> CPU: primitives_to_conserved_arr
  GPU: calculate_spatial_discretization_weno_gpu          <-> CPU: calculate_spatial_discretization_weno
  GPU: calculate_source_term_gpu                          <-> CPU: calculate_source_term
  GPU: solve_hyperbolic_step_standard_gpu                 <-> CPU: solve_hyperbolic_step_standard
  GPU: calculate_equilibrium_speed_gpu                    <-> CPU: calculate_equilibrium_speed
  GPU: apply_physical_state_bounds_gpu                    <-> CPU: apply_physical_state_bounds
  GPU: strang_splitting_step_gpu                          <-> CPU: strang_splitting_step
  GPU: central_upwind_flux_gpu                            <-> CPU: central_upwind_flux
  GPU: solve_hyperbolic_step_ssprk3_gpu                   <-> CPU: solve_hyperbolic_step_ssprk3
  GPU: conserved_to_primitives_arr_gpu                    <-> CPU: conserved_to_primitives_arr

================================================================================
âœ… Analysis complete! Results saved to: arz_model/architecture_analysis.txt
================================================================================
